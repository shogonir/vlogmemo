# オーダー記法

## 概要
ここでのオーダー記法は、アルゴリズムの性能（計算量）を評価するために使うものとします。  
特に、あるアルゴリズムで問題を解く（計算する）際にかかる時間などの性能を表現できます。  

ここからは、次のキーワードがでてきます。  
もしまだ知らないという方は前の動画や記事を参照ください。  
* リスト探索
* 線形探索
* 二分探索

オーダー記法を学ぶとどのようなメリットがあるのでしょうか。  
アルゴリズムの性能を評価できると、次のような問いに答えることができます。  

* 問1. 整列済みのリストを探索する場合、次の1と2のどちらが速いか？
  1. 線形探索
  2. 二分探索

* 問2. 整列されていないリストを探索する場合、次の1と2のどちらが速いか？
  1. 線形探索を使う
  2. 整列してから二分探索を使う

上記の問いの答えは1なのですが、このシリーズの最後で解説します。  

## 目次
* 計算量の種類
* オーダー記法
* 定数時間と、計算量の性質
* 計算量の導出
  * 線形探索
  * 二分探索
* 計算量の演算

## 計算量の種類
計算量とは、計算する（問題を解く）際に必要な量のことです。  
よく使う計算量は時間計算量と空間計算量です。  

```
計算量
+-- 時間計算量
+-- 空間計算量
```

時間計算量は問題を解く際にかかる時間のことです。  
この量が小さいほど、速く問題を解けるので優れていると言えます。  

空間計算量は問題を解く際に使用する空間のことです。  
計算する時の空間は、コンピュータ上のメモリなどの領域です。  
この量が小さいほど、限られたリソースで動作するので優れています。  

時間と空間のどちらが重要な指標であるかは状況によります。  
ただ、時間がかかることのストレスは人間が感じやすいので、  
一般的には時間の方を重視すると思っていいと思います。  
とはいえ、空間計算量が現実的である必要はもちろんあります。  

これらの計算量は、どのような状況を考えるかによっても変化します。  
例えば、 `最悪` , `平均` , `最良` などの状況があります。  
`最悪` はリスト探索の場合、最後まで要素が見つからないような状況で、 `最良` はその逆です。  
`平均` は色々な入力に対しての計算量の平均です。  

特に `最悪` と `平均` の計算量は使う機会が多いです。  
`最良` についてはそこまで使う機会は少ないと思います。  
`最良` の場合について考えても、「二分探索も線形探索も数ステップで問題を解く」ことが分かっても、二つのアルゴリズムの性能を比較することができないからです。  

```
計算量
 |
 +- 時間計算量
 |   +- 最悪時間計算量
 |   +- 平均時間計算量
 |   +- 最良時間計算量
 |   +- ...
 |
 +- 空間計算量
     +- 最悪時間計算量
     +- 平均時間計算量
     +- 最良時間計算量
     +- ...
```

## オーダー記法
オーダー記法は計算量を数学的に記述する方法です。  
まずは具体例から紹介します。  
例えば `O(n)` , `O(log(n))` , `O(n^2)` のように表記します。  
`O()` の中に数式を書くという決まりがあります。(O:order)  

数式に使うのは、問題の入力に登場する変数です。  
例えばリスト探索であれば、 `e` , `a` , `n` が使えます。  
線形探索と二分探索は `n` があれば表現できます。  

ここで問1について考えます。  
線形探索の最悪時間計算量は `O(n)` です。  
二分探索の最悪時間計算量は `O(log(n))` です。  
さて、線形探索と二分探索のうちどちらが速いのでしょうか。  

オーダー記法で表現された計算量を比較する際に重要な点があります。  
それは、「数式の中で使われる変数が十分に大きくなった時について考える」ことです。  
例えばリスト探索のアルゴリズムでは、入力のリスト長が大きければ大きいほど計算時間量が悪くなるはずです。  
こういった状況でも速く問題を解くことが、人間がアルゴリズムに求めることだからです。  

この考え方は、前の動画で `最良` ではなく `最悪` の状況を想定することが大事だと説明したことと似ています。  
しかし、変数が大きい時の数式を評価するのは `平均` の状況でも変わりませんので注意しましょう。  

さて問1に戻って考えてみましょう。
`n` が十分大きい時の、 `log(n)` と `n` を比較すれば良いです。  
これについてはグラフを見て考えると簡単です。  
グラフを見ると、「二分探索の方が線形探索より速い」と言えるのです。  

では下記のようになるのはなぜでしょうか？
* 線形探索の最悪時間計算量は `O(n)`
* 二分探索の最悪時間計算量は `O(log(n))`

また、問2について考えるにはまだ知識が必要です。
* 整列してから二分探索する時間計算量はどうやって求める？

## 定数時間と、計算量の性質
ここでは、計算量の性質を紹介します。  
計算量の性質を正しく理解することは、計算量の導出に不可欠です。  
少し抽象的な話になりますが、大事な部分ですのでゆっくり見てください。  

定数時間( `O(1)` )は、計算量の単位となる最小の計算時間のことです。  
アルゴリズムの計算量を導出するには、定数時間で行える計算を  
どれくらい繰り返せば終了するかを考える必要があります。  
まずは定数時間で行える計算を紹介します。  

以下の計算は、定数時間( `O(1)` )で計算できます。  
1. 配列の参照
2. 代入
3. 比較
4. 四則演算

いくつか注意事項があります。  
・配列の参照は定数時間ですが、連結リストなどだとまた別の計算時間になります。  
・四則演算も、厳密には演算する数の桁数によって時間計算量が変わります。  
ただ、一般的に探索する配列の長さの方が大きくなるので、ここでは定数時間とします。  

実は、線形探索や二分探索は以上で紹介した定数時間の計算を  
組み合わせたり繰り返すことで実現することができます。  

あとは、計算量の性質について知れば、アルゴリズムの計算量を導出できます。  
ということで、計算量の性質を説明したいと思います。  

### 計算量の性質
1. 最も大きくなる項だけを残す
2. 係数は消していい

これまでも説明してきましたが、とにかく変数が大きいときの計算量に興味があります。  
これらの性質は、実際に具体例を挙げて説明したいと思います。  

例えばあるアルゴリズムの計算が、定数時間の計算を
`3n^2 + 4n + 8` 回することで終了することがわかったとします。  

この時、計算量の性質1より、 `3n^2` の項だけ残せば良いとなります。  
他の `4n` や `8` の項に比べて、 `n` が大きい時に大きくなるからです。  

さらに性質2より、 `3n^2` の項の係数である `3` が不要となります。  
先ほどの説明でも伝わったと思いますが、係数は計算量にあまり影響しません。  

ここまでで計算量の性質については以上となります。  
この動画では下記の2点がポイントです。  

* 定数時間という最小単位の時間で行える計算がある  
* アルゴリズムの計算量は、定数時間の計算を何回ぐらい行うかで決まる  
* 計算量の性質は、小さな項や係数は影響が少ないため無視するというもの  

次回はついに計算量の導出について説明したいと思います。  

## 計算量の導出

では早速、線形探索の最悪時間計算量を導出します。  
線形探索の手続きを思い出してみましょう。  

### `linear_search(e, a, n)`
1. `i` を `0` とする
2. `a[i]` が `e` と等しければ `i` を返して終了、そうでなければ手順3に進む
3. `i` に `1` を足して `i` が `n` 以上であれば `-1` を返して終了、そうでなければ手順2に戻る

手順1の計算量は、代入を1回だけ行っているので `O(1)` です。  
手順2の計算量は、配列の参照＋比較を行うので `O(1 + 1) = O(2) = O(2 * 1) = O(1)` です。  
計算量の性質のうち、「係数は消していい」を適応しました。  
手順3の計算量は、足し算＋比較を行うので `O(1 + 1) = O(2) = O(2 * 1) = O(1)` です。
また計算量の性質のうち、「係数は消していい」を適応しました。  

あとはそれぞれの手順が、最悪の場合に何回行われるかを計算します。  
手順1は1回だけです。  
手順2は比較して等しければアルゴリズムが終了してしまいます。  
最悪の場合というのは、等しくなくて手順3に進むケースです。  
言い換えると、探している要素が配列内にない場合です。  
この場合、手順2は `n` 回実行されます。  
手順3も同様に、最悪の場合は `n - 1` 回実行されます。  

ここまで計算した、各手順の計算量に、その手順が実行される回数をかけて、足します。  
`O((1 * 1) + (1 * n) + (1 * (n - 1)))` これが線形探索の最悪時間計算量です。  
あとは、計算量の性質を使って簡単にしていきます。  
`O((1 * 1) + (1 * n) + (1 * (n - 1))) = O(1 + n + n - 1) = O(2n) = O(n)` となります。  
以上で、線形探索の最悪時間計算量が導出できました。  

続いて二分探索の最悪時間計算量を導出します。  

### `binary_search(e, a, imin, imax)`
1. もし `imax < imin` であれば `-1` を返す。そうでなければ手順2に進む
2. リストの探索範囲の真ん中の番号を `imid <- imin + (imax - imin) / 2` とし、真ん中の要素を `mid <- a[imid]` とする
3. もし `mid > e` であれば現在の探索範囲の左半分が次の探索範囲となるため `binary_search(e, a, imin, imid - 1)` を返す。そうでなければ手順4に進む
4. もし `mid < e` であれば現在の探索範囲の右半分が次の探索範囲となるため `binary_search(e, a, imid + 1, imax)` を返す。そうでなければ手順5に進む
5. `mid = e` であるため、 `imid` を返す

二分探索は、二分探索中に二分探索を行う再帰的なアルゴリズムなので、  
まずは1回の二分探索を実行した際にかかる計算量を導出します。  

手順1は比較をおこなうので `O(1)` です。  
手順2は代入＋四則演算＋配列の参照なので `O(1)` です。  
手順3は比較＋二分探索ですが、今は二分探索の計算時間量を計算しているので、  
比較にかかる `O(1)` だけを考えたいと思います。手順3も `O(1)` です。  
手順4も同様に `O(1)` です。  
手順5は代入なので `O(1)` です。  
ということで、1回の二分探索にかかる計算量は `O(1)` です。  

あとはこの二分探索が何回実行されるかを求めます。  
最悪の場合、要素が見つからず何回も二分探索を行うことになりますが、  
このときに二分探索は何回実行されるのか考えます。  

たとえば `n = 4` だとしましょう。  
探索範囲は1回の二分探索で半分になっていくので、  
`4 -> 2 -> 1 -> 0` のように減っていきます。  
これは `n = 2^(m-1)` だとすると `m` 回実行されるという法則になっています。  
`m` を `n` で表すと、 `m - 1 = log2(n) -> m = log2(n) + 1` となります。  
つまり、二分探索は `log2(n) + 1` 回実行されます。  

`O(1)` の二分探索を `O(log2(n))` 回実行されるので、  
最終的な最悪時間計算量は `O(log2(n))` となります。  

以上でリスト探索の2つのアルゴリズムの最悪時間計算量を導出しました。  
1. 線形探索の最悪時間計算量は `O(n)` 
2. 二分探索の最悪時間計算量は `O(log2(n))`

アルゴリズムの計算量を導出するには、各手順の計算量と、  
その手順が実行される回数をかけて足すことで導出できます。  

次の動画では、計算量同士の演算を使って、問2を説明します。  

## 計算量の演算

計算量の演算は、基本的には数式の演算と何も変わりません。  
特殊なことがあるとすれば、計算量の性質を使って簡略化できるというところです。  

これについて早速、具体例で説明していきたいと思います。  

* 問2. 整列されていないリストを探索する場合、次の1と2のどちらが速いか？
  1. 線形探索を使う
  2. 整列してから二分探索を使う

どちらの選択肢の方が速いかを知るために、それぞれの速さを求めます。  
今回は最悪時間計算量を評価指標として、比較していきます。  

まずは選択肢1についてですが、線形探索の方はすでに  
最悪時間計算量が `O(n)` であることを導出しました。  

続いて選択肢2ですが、ここで計算量の演算が必要です。  
「整列してから二分探索」の計算量を求めたいので、  
こういう場合は整列と二分探索の計算量の和を計算します。  

まず二分探索の最悪時間計算量は以前紹介した通り `O(log(n))` です。  
整列の最悪時間計算量は `0(n * log(n))` です。  

この2つの計算量を足すには、そのまま数式として足します。  
ということで、「整列してから二分探索」の最悪時間計算量は  
`O(log(n) + n*log(n))` となります。  

ここで計算量の性質「最大の項のみを残す」を適応します。  
`n` が十分に大きい時に大きくなる項はどちらでしょうか。  
これはもちろん `n * log(n)` になりますね。  
ということで「整列してから二分探索」は `O(n*log(n))` となります。  

* 問2. 整列されていないリストを探索する場合、次の1と2のどちらが速いか？
  1. 線形探索を使う（最悪時間計算量は `O(n)` ）
  2. 整列してから二分探索を使う（最悪時間計算量は `O(n*log(n))` ）

最終的に、問2の答えは「選択肢2の方が速い」となります。  

## さいごに

オーダー記法シリーズは以上となります。  
オーダー記法の重要な部分をお伝えできたと思います。  

* 計算量の種類
* オーダー記法
* 定数時間と、計算量の性質
* 計算量の導出
  * 線形探索
  * 二分探索
* 計算量の演算

オーダー記法の延長線上ということで「整列」のシリーズや、  
すこし違う方向として「データ構造」のシリーズもやりたいと思います。  